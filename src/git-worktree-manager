#!/bin/sh

set -o errexit
set -o nounset
set -o pipefail

# git worktree manager – CLI.

###############################################################################
# Variables for configuration.
###############################################################################

PROJECTS_DIR="${GWM_PROJECTS_DIR?Projects directory must be set.}"
WORKTREES_DIR="${GWM_WORKTREES_DIR?Worktrees directory must be set.}"

INITIALIZATION_HOOK_FILENAME="init.sh"
OPEN_HOOK_FILENAME="open.sh"
ACTIVATION_HOOK_FILENAME="activate.sh"

###############################################################################
# Helper functions.
###############################################################################

get_projects_dir() {
    if [ -z "$PROJECTS_DIR" ]; then
        exit_with_error "PROJECTS_DIR environment variable is not set."
    fi

    normalize_dir_path "$PROJECTS_DIR"
}

get_worktrees_dir() {
    if [ -z "$WORKTREES_DIR" ]; then
        exit_with_error "WORKTREES_DIR environment variable is not set."
    fi

    normalize_dir_path "$WORKTREES_DIR"
}

# normalize_dir_path PATH
# Normalize a directory path by removing trailing slashes.
normalize_dir_path() {
    if [ "$#" -ne 1 ]; then
        exit_with_error "normalize_dir_path: Invalid number of arguments."
    fi

    path="$1"
    normalized="${path%/}" # Remove trailing slashes.

    # If the result is empty, the input was "/" or "//".
    if [ -z "$normalized" ]; then
        exit_with_error "normalize_dir_path: Normalization result is root path."
    fi

    printf "%s\n" "$normalized"
}

exit_with_usage() {
    bin_name="${0##*/}"
    cat <<EOF
git worktree manager – Manage Git worktrees.

Usage: $bin_name <command> [args]

COMMANDS
  init <branch>          Initialize a new worktree for the specified branch,
                         and trigger the "init" hook.
  open <worktree>        "Open the specified worktree", i.e., trigger the
                         "open" hook.
  activate <worktree>    "Activate the specified worktree", i.e., trigger the
                         "activate" hook.
  remove <worktree>      Remove the specified worktree.
  find <query>           Find a worktree and return its path.
  prune                  Prune worktree information.
  list                   List all worktrees.

Commands are interactive when possible, using fzf for selection.

HOOKS
  init        Runs when initializing a worktree ("$INITIALIZATION_HOOK_FILENAME").
  open        Runs when opening a worktree ("$OPEN_HOOK_FILENAME").
  activate    Runs when activating a worktree ("$ACTIVATION_HOOK_FILENAME").

Hook files can be placed per repository in their repository-specific worktrees
directory, and will be run, if present.

EXAMPLES
  $bin_name init feature/new-api
  $bin_name open
  $bin_name activate
  $bin_name find my-feature
EOF
    exit 1
}

exit_with_error() {
    message="$1"
    code="${2:-1}"
    printf "%s\n" "$message" >&2
    exit "$code"
}

# Validate that the application is working inside a Git repository.
validate_in_git_repository() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        exit_with_error "Not in a Git repository."
    fi
}

# get_worktree_dir PROJECTS_DIR WORKTREES_DIR BRANCH_NAME
# Get the path to the directory for the specified branch.
get_worktree_dir() {
    if [ "$#" -ne 3 ]; then
        exit_with_error "get_worktree_dir: Invalid number of arguments."
    fi

    projects_dir="$1"
    worktrees_dir="$2"
    branch_name="$3"

    repo_root="$(git rev-parse --show-toplevel)" || exit 1
    if ! is_subdir "$projects_dir" "$repo_root"; then
        exit_with_error "Repository not in project directory."
    fi

    # Get the repository directory path relative to the worktrees directory.
    projects_dir_abs="$(abspath "$projects_dir")" || exit 1
    repo_abs="$(abspath "$repo_root")" || exit 1
    repo_rel="${repo_abs#"$projects_dir_abs"/}"

    dir_name="$(branch_name_to_dir_name "$branch_name")"

    printf "%s\n" "${worktrees_dir}/$repo_rel/$dir_name"
}

# get_local_branch_name BRANCH_NAME
# Extract local branch name from a branch reference (strips remote prefix if present).
get_local_branch_name() {
    if [ "$#" -ne 1 ]; then
        exit_with_error "get_local_branch_name: Invalid number of arguments."
    fi

    branch_name="$1"
    local_branch="$branch_name"

    for remote in $(git remote); do
        case "$branch_name" in
            "$remote"/*)
                local_branch="${branch_name#"$remote"/}"
                break
                ;;
        esac
    done

    printf "%s\n" "$local_branch"
}

# branch_name_to_dir_name BRANCH_NAME
branch_name_to_dir_name() {
    if [ "$#" -ne 1 ]; then
        exit_with_error "branch_name_to_dir_name: Invalid number of arguments."
    fi

    branch_name="$1"
    # Replace all slashes with underscores to prevent a nested directory.
    printf "%s\n" "$branch_name" | tr '/' '_'
}

# abspath PATH
# Print the canonical absolute path to stdout, returns non-zero on failure.
abspath() {
    if [ "$#" -ne 1 ]; then
        exit_with_error "abspath: Invalid number of arguments."
    fi

    (cd "$1" 2>/dev/null && pwd) || return 1
}

# is_subdir BASE_PATH SUBDIR_CANDIDATE_PATH
# Returns:
#   0, if SUBDIR_CANDIDATE_PATH is BASE_PATH or is located under BASE_PATH.
#   1, otherwise.
is_subdir() {
    if [ "$#" -ne 2 ]; then
        exit_with_error "is_subdir: Invalid number of arguments."
    fi

    base=$1
    child=$2

    base_abs=$(abspath "$base") || return 1
    child_abs=$(abspath "$child") || return 1

    case $child_abs in
        "$base_abs" | "$base_abs"/*) return 0 ;;
        *) return 1 ;;
    esac
}

# exec_hook EXECUTABLE_NAME WORKTREE_DIR
# Execute the specified executable with the specified worktree directory.
exec_hook() {
    if [ "$#" -ne 2 ]; then
        exit_with_error "exec_hook: Invalid number of arguments."
    fi

    executable_name="$1"
    worktree_dir="$2"

    # Only run hooks for worktrees inside the worktrees directory.
    is_subdir "$WORKTREES_DIR" "$worktree_dir" || return 1

    executable="$(dirname "$worktree_dir")/$executable_name"
    if [ -f "$executable" ] && [ -x "$executable" ]; then
        "$executable" "$worktree_dir"
    fi

    return 0
}

###############################################################################
# Commands.
###############################################################################

init_worktree() {
    validate_in_git_repository
    query="$*"
    branch_name="$(
        git branch --all --format="%(refname:short)" |
            fzf --preview='git log --oneline -n10' --query "$query"
    )"

    local_branch_name="$(get_local_branch_name "$branch_name")"

    projects_dir="$(get_projects_dir)" || exit 1
    worktrees_dir="$(get_worktrees_dir)" || exit 1
    if ! worktree_dir="$(
        get_worktree_dir "$projects_dir" "$worktrees_dir" "$local_branch_name"
    )"; then
        exit_with_error "Failed to get worktree directory."
    fi

    mkdir -p "$worktree_dir"

    # If remote branch selected, create local tracking branch. Otherwise use branch directly
    if [ "$local_branch_name" != "$branch_name" ]; then
        if ! git worktree add -b "$local_branch_name" "$worktree_dir" "$branch_name"; then
            exit_with_error "Failed to add worktree at $worktree_dir."
        fi
    else
        if ! git worktree add "$worktree_dir" "$branch_name"; then
            exit_with_error "Failed to add worktree at $worktree_dir."
        fi
    fi
    printf "%s\n" "Added worktree at $worktree_dir."

    exec_hook "$INITIALIZATION_HOOK_FILENAME" "$worktree_dir"
    printf "%s\n" "Initialized worktree at $worktree_dir."
}

open_worktree() {
    validate_in_git_repository
    query="$*"
    worktree_dir="$(
        git worktree list |
            fzf --preview='git log --oneline -n10 {2}' --query "$query" |
            awk '{print $1}'
    )"
    exec_hook "$OPEN_HOOK_FILENAME" "$worktree_dir"
    printf "%s\n" "Opened worktree at ${worktree_dir}."
}

activate_worktree() {
    validate_in_git_repository
    query="$*"
    worktree_dir="$(
        git worktree list |
            fzf --preview='git log --oneline -n10 {2}' --query "$query" |
            awk '{print $1}'
    )"
    exec_hook "$ACTIVATION_HOOK_FILENAME" "$worktree_dir"
    printf "%s\n" "Activated worktree at ${worktree_dir}."
}

remove_worktree() {
    validate_in_git_repository
    query="$*"
    worktree_dir="$(
        git worktree list |
            fzf --preview='git log --oneline -n10 {2}' --query "$query" |
            awk '{print $1}'
    )"

    if git worktree remove "${worktree_dir}"; then
        printf "%s\n" "Removed worktree at ${worktree_dir}."
    else
        exit_with_error "Failed to remove worktree at ${worktree_dir}."
    fi
}

find_worktree() {
    validate_in_git_repository
    query="$*"
    printf "%s\n" "$(
        git worktree list |
            fzf --preview='git log --oneline -n10 {2}' --query "$query" |
            awk '{print $1}'
    )"
}

prune_worktrees() {
    validate_in_git_repository
    if git worktree prune; then
        printf "%s\n" "Pruned worktree information."
    else
        exit_with_error "Failed to prune worktree information."
    fi
}

list_worktrees() {
    validate_in_git_repository
    git worktree list
}

###############################################################################
# Entry point.
###############################################################################

main() {
    if [ "$#" -eq 0 ]; then
        exit_with_usage
    fi

    command="$1"
    shift

    case "$command" in
        init) init_worktree "$@" ;;
        open) open_worktree "$@" ;;
        activate) activate_worktree "$@" ;;
        remove) remove_worktree "$@" ;;
        find) find_worktree "$@" ;;
        prune) prune_worktrees "$@" ;;
        list) list_worktrees "$@" ;;
        *) exit_with_usage ;;
    esac
}

main "$@"
